<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Route Optimization Fixed</title>

  <!-- Leaflet CSS and JS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Leaflet GeoSearch CSS and JS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet-geosearch@3.0.0/dist/geosearch.css"
  />
  <script src="https://unpkg.com/leaflet-geosearch@3.0.0/dist/bundle.min.js"></script>

  <!-- Axios -->
  <script src="https://cdn.jsdelivr.net/npm/axios@0.21.1/dist/axios.min.js"></script>

  <style>
    #map {
      height: 500px;
      width: 100%;
    }
    #controls {
      margin-top: 10px;
    }
    .leaflet-control.geosearch {
      z-index: 1000;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="controls">
    <button onclick="getRoute()">Get Best Route</button>
    <button onclick="clearMap()">Clear</button>
  </div>
  <div id="route-options"></div>
  <div id="route-info"></div>

  <script>
    const API_KEY = "a3645687-316d-4561-9116-becbd1dfac3a"; // Replace with your valid key

    // Initialize map
    const map = L.map("map").setView([31.95013, 35.92487], 14);

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      attribution: "&copy; OpenStreetMap contributors",
    }).addTo(map);

    // Setup GeoSearch provider and control
    const provider = new GeoSearch.OpenStreetMapProvider();

    const searchControl = new GeoSearch.GeoSearchControl({
      provider: provider,
      style: "bar",
      showMarker: true,
      autoClose: true,
      retainZoomLevel: false,
      animateZoom: true,
      searchLabel: "Search for a place",
      keepResult: true,
      position: "topleft",
    });

    map.addControl(searchControl);

    // Fix: Add searched location to points and markers on search event
    map.on("geosearch/showlocation", function (result) {
      const latlng = result.location;
      addPoint(latlng.y, latlng.x);
    });

    let markers = [];
    let points = [];
    let polylines = [];
    let selectedRoute = null;

    // Click on map to add point
    map.on("click", function (e) {
      if (points.length < 8) {
        addPoint(e.latlng.lat, e.latlng.lng);
      } else {
        alert("You can only select up to 8 points.");
      }
    });

    // Reusable function to add marker and store point
    function addPoint(lat, lng) {
      points.push([lat, lng]);
      const pointNumber = points.length;
      const marker = L.marker([lat, lng])
        .addTo(map)
        .bindTooltip(`Point ${pointNumber}`, { permanent: true, direction: "top" })
        .openTooltip();
      markers.push(marker);
    }

    async function getRoute() {
      if (points.length < 2) {
        alert("Please select at least two points.");
        return;
      }
      if (API_KEY === "REPLACE_WITH_YOUR_GRAPHOPPER_API_KEY") {
        alert("Please replace the placeholder API key with a valid GraphHopper API key.");
        return;
      }

      // GraphHopper expects multiple points as query parameters (GET)
      // Construct URL with multiple points
      let url = `https://graphhopper.com/api/1/route?key=${API_KEY}&profile=car&locale=en&instructions=true&calc_points=true&points_encoded=false&optimize=true&alternative_route.max_paths=3&alternative_route.max_weight_factor=1.4&alternative_route.max_share_factor=0.6&ch.disable=true`;

      points.forEach((p) => {
        url += `&point=${p[0]},${p[1]}`;
      });

      try {
        const response = await axios.get(url);
        console.log("API Response:", response.data);
        displayRoutes(response.data.paths);
      } catch (error) {
        console.error("Error fetching route:", error.response ? error.response.data : error);
        alert("Failed to fetch route. Check API key and internet connection.");
      }
    }

    function displayRoutes(routes) {
      clearPolylines();
      document.getElementById("route-options").innerHTML = "<strong>Select a Route:</strong><br>";

      routes.forEach((route, index) => {
        const optimizedRoute = route.points.coordinates.map((c) => [c[1], c[0]]);
        const polyline = L.polyline(optimizedRoute, { color: index === 0 ? "blue" : "gray" }).addTo(map);
        polylines.push(polyline);

        const routeBtn = document.createElement("button");
        routeBtn.innerHTML = `Route ${index + 1}: ${(route.distance / 1000).toFixed(2)} km, ${Math.round(route.time / 60000)} min`;
        routeBtn.onclick = () => highlightRoute(index, route);

        const geofenceBtn = document.createElement("button");
        geofenceBtn.innerHTML = "‚ûï Add as Geofence";
        geofenceBtn.style.marginLeft = "10px";
        geofenceBtn.onclick = () => {
          createGeofenceFromRoute(route);
        };

        document.getElementById("route-options").appendChild(routeBtn);
        document.getElementById("route-options").appendChild(geofenceBtn);
        document.getElementById("route-options").appendChild(document.createElement("br"));
      });
    }

    function highlightRoute(index, route) {
      clearPolylines();
      selectedRoute = route;
      const optimizedRoute = route.points.coordinates.map((c) => [c[1], c[0]]);
      const polyline = L.polyline(optimizedRoute, { color: "green", weight: 5 }).addTo(map);
      polylines.push(polyline);

      document.getElementById("route-info").innerHTML = `
            <strong>Selected Route</strong><br>
            Distance: ${(route.distance / 1000).toFixed(2)} km<br>
            Time: ${Math.round(route.time / 60000)} minutes<br>
        `;
    }

    function clearMap() {
      markers.forEach((marker) => map.removeLayer(marker));
      clearPolylines();
      markers = [];
      points = [];
      document.getElementById("route-options").innerHTML = "";
      document.getElementById("route-info").innerHTML = "";
    }

    function clearPolylines() {
      polylines.forEach((polyline) => map.removeLayer(polyline));
      polylines = [];
    }

    async function createGeofenceFromRoute(route) {
      if (!route || !route.points || !route.points.coordinates) {
        alert("Please select a route first.");
        return;
      }

      const name = prompt("Enter Geofence Name:");
      if (!name) return;

      const coords = route.points.coordinates.map((c) => ({
        lat: c[1],
        lng: c[0],
      }));

      // Format as LINESTRING with lng lat (WKT requires lng lat order)
      const linestring = "LINESTRING(" + coords.map((p) => `${p.lng} ${p.lat}`).join(", ") + ")";

      const attributes = { type: "route" };

      const body = JSON.stringify({
        name,
        area: linestring,
        attributes,
      });

      try {
        const response = await fetch("https://gotesting.bazytrack.jo/api/geofences", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Accept: "application/json",
            Authorization:
              "Bearer SDBGAiEAuV88T7FwnfMQHa_944gUko6UeE3wDnAwiqWk_WpZsMQCIQD6IaMHO_d4B2orP6ubCzBBnr7vSyZEbuAf67BXs9ewp3sidSI6MSwiZSI6IjIwMjYtMDYtMDRUMjE6MDA6MDAuMDAwKzAwOjAwIn0",
          },
          body: body,
        });
        if (response.ok) {
          alert("Route created successfully. üëç");
        } else {
          const result = await response.text();
          alert("üî¥ Error: " + result);
        }
      } catch (error) {
        console.error("Error sending request:", error);
        alert("Failed to create geofence.");
      }
    }
  </script>
</body>
</html>
